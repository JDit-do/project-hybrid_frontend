name: FE CI on ECR

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      bump_minor:
        description: "버전 증가(true=minor+1, false=patch+1)"
        required: false
        type: boolean
        default: false

permissions:
  id-token: write
  contents: write
  pull-requests: write

env:
  # AWS 정보
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPO: ${{ secrets.ECR_REPO }}
  IMAGE_TAG: ${{ github.sha }}
  ALLOW_CREATE_ECR: "false" # ECR 생성 시도

  # Repo 정보
  ENV_CONFIG_REPO: ${{ secrets.ENV_CONFIG_REPO }}
  DEV_VALUES_PATH: ${{ secrets.DEV_VALUES_PATH }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout app
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Assert STS
        run: aws sts get-caller-identity

      - name: Login to Amazon ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Guard variables
        run: |
          set -eu
          : "${ECR_REPO:?ECR_REPO empty}"
          : "${IMAGE_TAG:?IMAGE_TAG empty}"
          echo "REGISTRY=${{ steps.ecr.outputs.registry }}"

      # (옵션) vX.Y.Z 산정
      - name: Resolve version tag (vX.Y.Z)
        id: ver
        env:
          DEFAULT_MAJOR: "1"
        shell: bash
        run: |
          set -euo pipefail
          BUMP="${{ github.event.inputs.bump_minor }}"
          BUMP="$(echo "${BUMP:-false}" | tr '[:upper:]' '[:lower:]')"
          EXISTING=$(
            aws ecr describe-images \
              --repository-name "${ECR_REPO}" \
              --query "imageDetails[].imageTags[]" \
              --output text 2>/dev/null | tr '\t' '\n' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' || true
          )
          MAJOR="${DEFAULT_MAJOR}"
          if [ -n "${EXISTING}" ]; then
            CUR_MINOR_MAX=$(printf '%s\n' ${EXISTING} \
              | awk -F'[v\\.]' -v maj="${MAJOR}" '$2==maj {print $3}' \
              | sort -n | tail -n1)
            CUR_MINOR_MAX="${CUR_MINOR_MAX:-0}"
          else
            CUR_MINOR_MAX="0"
          fi
          if [ "${BUMP}" = "true" ]; then
            MINOR=$(( CUR_MINOR_MAX + 1 )); PATCH=0
          else
            MINOR="${CUR_MINOR_MAX}"
            if [ -n "${EXISTING}" ]; then
              PATCH_MAX=$(printf '%s\n' ${EXISTING} \
                | awk -F'[v\\.]' -v maj="${MAJOR}" -v min="${MINOR}" '$2==maj && $3==min {print $4}' \
                | sort -n | tail -n1)
              PATCH=$([ -z "${PATCH_MAX:-}" ] && echo 0 || echo $((PATCH_MAX + 1)))
            else
              PATCH=0
            fi
          fi
          VERSION_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          echo "version=${VERSION_TAG}" >> "$GITHUB_OUTPUT"
          echo "::notice:: VERSION_TAG=${VERSION_TAG}"

      - name: Build image
        run: docker build -t $ECR_REPO:$IMAGE_TAG .

      - name: Ensure ECR repo exists (describe or create)
        env:
          REGISTRY: ${{ steps.ecr.outputs.registry }}
        run: |
          set -euo pipefail
          if aws ecr describe-repositories --repository-names "$ECR_REPO" --region "$AWS_REGION" >/dev/null 2>&1; then
            echo "ECR repo found: $ECR_REPO"
          elif [ "$ALLOW_CREATE_ECR" = "true" ]; then
            echo "Creating ECR repo: $ECR_REPO"
            aws ecr create-repository --repository-name "$ECR_REPO" --region "$AWS_REGION" >/dev/null
          else
            echo "ECR repo '$ECR_REPO' not found. Create it once or set ALLOW_CREATE_ECR=true."
            exit 1
          fi

      - name: Tag image for ECR
        env:
          REGISTRY: ${{ steps.ecr.outputs.registry }}
        run: |
          docker tag $ECR_REPO:$IMAGE_TAG $REGISTRY/$ECR_REPO:$IMAGE_TAG
          docker tag $ECR_REPO:$IMAGE_TAG $REGISTRY/$ECR_REPO:${{ steps.ver.outputs.version }}
          docker tag $ECR_REPO:$IMAGE_TAG $REGISTRY/$ECR_REPO:latest

      - name: Push image
        env:
          REGISTRY: ${{ steps.ecr.outputs.registry }}
        run: |
          docker push $REGISTRY/$ECR_REPO:$IMAGE_TAG
          docker push $REGISTRY/$ECR_REPO:${{ steps.ver.outputs.version }}
          docker push $REGISTRY/$ECR_REPO:latest

      # ----- GitOps: env_config 값 파일 커밋(Dev) -----
      - name: Skip on fork PR (no secrets)
        id: forkcheck
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ] && [ "${{ github.event.pull_request.head.repo.fork }}" = "true" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Guard PAT
        if: steps.forkcheck.outputs.skip == 'false'
        run: |
          test -n "${{ secrets.ENV_REPO_PAT }}" || (echo "ENV_REPO_PAT is empty"; exit 1)

      - name: Checkout env_config repo
        if: steps.forkcheck.outputs.skip == 'false'
        uses: actions/checkout@v4
        with:
          repository: ${{ env.ENV_CONFIG_REPO }}
          token: ${{ secrets.ENV_REPO_PAT }}
          path: envcfg

      - name: Install yq
        if: steps.forkcheck.outputs.skip == 'false'
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.2/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Update values-dev.yaml (image.tag -> SHA)
        if: steps.forkcheck.outputs.skip == 'false'
        env:
          FILE: envcfg/${{ env.DEV_VALUES_PATH }}
        run: |
          set -euo pipefail
          test -f "$FILE"
          yq -i '.image.tag = strenv(IMAGE_TAG)' "$FILE"
          echo "Updated:"
          yq '.image' "$FILE"

      - name: Commit & push to main (Dev auto)
        if: steps.forkcheck.outputs.skip == 'false'
        working-directory: envcfg
        run: |
          git config user.name  "ci-bot"
          git config user.email "ci-bot@example.com"
          git add "${{ env.DEV_VALUES_PATH }}"
          git commit -m "chore(dev): image.tag -> ${IMAGE_TAG} (also ${{ steps.ver.outputs.version }})" || exit 0
          git push origin HEAD:main
